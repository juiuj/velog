<p>처음 프로젝트를 진행하며 EC2 배포를 해봤을 때의 기억은 대체로 비슷하다.. Node 버전 설치하고,, 패키지 설치하고,, 환경 변수 맞추고,,포트 열고,, 뭐 어찌저찌 하면 일단 돌아가는 서버(..)는 만들어진다.</p>
<p>문제는 그 다음부터다.
EC2 배포를 한 번이라도 해봤다면, 아래 상황 중 하나 쯤은 겪어봤을 가능성이 높다 🤯</p>
<ul>
<li>로컬에서는 잘 되던 앱이 서버에서는 에러 남;</li>
<li>분명 어제까지 되던 코드가 오늘 서버에서는 안된다;;</li>
<li>같은 레포를 다른 EC2에 올렸는데 결과가 다름;;;
<del>나같경 다 겪어봄;;;;;;;;;;;;</del></li>
</ul>
<p>이때 우리가 흔하게 하는 말이 있다
&quot;아마 서버 환경이 달라서 그런 거 같아요..&quot;
이 말인 즉슨, 문제의 원인이 코드가 아니라 환경일 수도 있다는 사실이다 💦</p>
<p>지금부터 알아보려는 <code>Docker</code>는 위와 같은 상황에 대하여 <strong>코드 뿐만 아니라 실행 환경 자체를 함께 관리할 수는 없을까?</strong> 라는 질문에 대한 답으로 등장했다.</p>
<hr />
<h1 id="docker란">Docker란?</h1>
<p><code>Docker</code>를 한 문장으로 정의하자면 이렇게 말할 수 있다👇👇👇</p>
<blockquote>
<p><strong>애플리케이션과 그 실행 환경을 하나로 묶어서 어디서든 같은 조건으로 실행되게 만드는 기술</strong></p>
</blockquote>
<h2 id="vm-vs-docker---뭐가-다른가">VM vs Docker - 뭐가 다른가?!</h2>
<p>우선 VM(VirtualMachine)부터 보자!
<code>VM</code>은 하나의 서버 위에 또 다른 완전한 서버를 통째로 올리는 방식이라 볼 수 있다.
즉, 애플리케이션을 실행하기 위해 필요한 것뿐만 아니라 <strong>운영체제(OS)까지 함께 포함해서 하나의 가상 머신</strong>으로 만든다.</p>
<p>🙋‍♀️ 그 결과, 각 VM은 독립적인 OS를 가지게 되는데 .. 그만큼 부팅이 느리고, 자원 사용량이 커지게 된다.
환경이 완전히 분리된다는 안정성은 있지만,, 무거워지는 건 어쩔 수 없다;</p>
<p><strong>❗️반면에❕</strong>
<code>Docker</code>는 접근 방식이 다르다.
VM과 달리 OS를 새로 만들지 않고, *<code>호스트 OS</code>를 여러 *<code>컨테이너</code>가 공유한다. 
즉, OS는 공유하고, 실행 환경만 분리함!</p>
<p>그래서 OS를 포함하지 않기 때문에 가볍고, 바로 실행할 수 있어서 빠르며, 같은 환경을 여러 곳에 쉽게 복제할 수도 있다.</p>
<p>*호스트 OS: Docker나 VM을 실행하고 있는 찐또배기 운영체제
*컨테이너는 아래에서 설명</p>
<h2 id="컨테이너-이미지">컨테이너? 이미지?</h2>
<p><code>Docker</code> 이야기를 어렵게 만드는 단어가 바로 <code>이미지</code>와 <code>컨테이너</code>이다.
이게 뭐인고 싶어서 공식 정의부터 보면 오히려 더 헷갈린다;</p>
<p>지피티왈,</p>
<ul>
<li>이미지: 애플리테이션이 실행되기 위한 환경의 설계도</li>
<li>컨테이너: 그 설계도로부터 실제로 실행 중인 결과물</li>
</ul>
<p>로 이해하면 된단다.</p>
<p>조금 더 이해하기 쉽게는,
<code>이미지</code>는 &quot;이 앱은 이런 환경에서 실행돼야 해&quot; 라고 적어둔 <strong>묶음 설명서</strong>고, <code>컨테이너</code>는 그 설명서를 기반으로 실제로 떠 있는 <strong>실행 상태의 앱</strong>이다.</p>
<h3 id="ec2-배포의-경험이랑은-어떻게-이어볼-수-있으까">EC2 배포의 경험이랑은 어떻게 이어볼 수 있으까</h3>
<p>EC2에 직접 배포할 때를 떠올려보면 우리는 보통 아래와 같은 과정을 거친다👇</p>
<blockquote>
<p>서버에 접속 -&gt; Node버전 맞추기 -&gt; 패키지 설치 -&gt; 환경 변수 설정 -&gt; &quot;이 서버에서는 이렇게 돌아가게 하자&quot;는 결정(?)</p>
</blockquote>
<p>이 모든 과정이 사실상 <code>이미지</code>를 손으로 만들고 있던 셈이다..🤯
다만 그 이미지가 코드로 남아 있지 않고 서버 안에서만 흩어져 있었을 뿐..</p>
<p><img alt="" src="https://velog.velcdn.com/images/dev-joohee/post/d0114eb7-1577-431c-a705-339f1fde11b2/image.png" /></p>
<p>docker는 이 과정을 뒤집어서 &quot;이 서버에서 뭘 설치하지?&quot;가 아니라 <strong>&quot;이 앱이 실행되기 위해서 필요한 환경은 뭐지?&quot;</strong> 를 먼저 정의한다!</p>
<p>그 정의가 <code>이미지</code>가 되고, 그 이미지를 실행한 결과가 <code>컨테이너</code>다<em>!</em></p>
<blockquote>
<p>기존(EC2)에는 &quot;이 EC2에서 이 코드가 잘 돌게 만들자&quot; 였다면, Docker 이후에는 <strong>&quot;어디서든 이 이미지를 실행하면 같은 결과가 나오게 만들자&quot;</strong>가 된다</p>
</blockquote>
<p>그래서 Docker를 쓰는 배포는 서버에 의존하는 작업이 아니라 <strong>실행 환경을 전달하는 작업</strong>에 가깝다❕</p>
<hr />
<h3 id="docker는-실제로-어디에서-쓰일까">Docker는 실제로 어디에서 쓰일까?</h3>
<p>여기까지 읽었다면, Docker가 단순히 로컬 개발용 도구가 아니라 <strong>배포와 실행 환경을 다루는 방식 자체를 바꾸는 기술</strong> 라는 건 감이 왔을 것이다!</p>
<p>그래서 Docker는 주로 아래와 같은 상황에서 쓰인다 👇</p>
<blockquote>
<ul>
<li>개발자마다 다른 환경에서 작업하던 문제를 줄이고 싶을 때</li>
</ul>
</blockquote>
<ul>
<li>서버가 여러 대로 늘어나면서 환경 재현이 어려워질 때</li>
<li>배포 과정을 사람의 손이 아니라 규칙으로 관리하고 싶을 때</li>
</ul>
<p>이때 docker는 &quot;서버마다 설정을 맞추자&quot;가 아니라 <strong>&quot;이 이미지를 어디서나 실행하자&quot;</strong>라는 선택지를 만든다!
.
.
그 이후부터는 또 다른 도구들이 자연스럽게 쓰이는데 그건 기회가 되면 다른 글에서 다뤄보겠다.</p>
<hr />
<p>Docker를 공부하며 모 유튜버의 영상을 참고했는데 요즘앤 코딩 처음 시작할 때 Docker 설치부터 배운다고 하던데..
수동 배포를 겪어봐야 하는데 도커부터 배우는 점이 안타깝다고 하던데 그 부분엔 나도 약간 동의.
수동배포하면서 참교육을 당하고 나면 도커가 더더더 고트하게 느껴질 것 같다
끝</p>