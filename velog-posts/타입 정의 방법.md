<h1 id="type-script-문법">Type Script 문법</h1>
<h2 id="함수의-타입-정의">함수의 타입 정의</h2>
<pre><code>function sum(a: number, b: number) : number{
    return a+b;
}</code></pre><ul>
<li>함수 선언: sum이라는 이름의 함수를 정의하고 있.</li>
<li>매개변수 타입:</li>
<li>이 함수는 숫자 두 개를 입력받는 코드로 <em><strong>a: number</strong>_와 _<strong>b: number:</strong></em> 두 개의 매개변수 a와 b는 모두 숫자(number) 타입으로 명시되어 있음. </li>
<li>반환 타입:</li>
<li><em><strong>: number</strong></em> 이 부분은 함수의 반환값이 숫자 타입이어야 한다는 것을 나타냄.</li>
<li><em><strong>return a + b</strong></em>: 두 매개변수 a와 b를 더한 값을 반환함. 이 연산 결과도 숫자이므로 함수의 반환 타입 조건을 만족함.</li>
</ul>
<h3 id="알아야-하는-타입스크립트-개념">알아야 하는 타입스크립트 개념</h3>
<ul>
<li>함수의 타입 정의 방법</li>
<li>타입 추론</li>
<li>함수의 파라미터 타입 정의</li>
<li>함수의 반환 타입 정의
  <strong>tip</strong> 타입표기 - 타입을 정의하는 방식: number:string</li>
</ul>
<h2 id="타입-스크립트-기본타입">타입 스크립트 기본타입</h2>
<ul>
<li><p>문자열(String): 자바스크립트 변수의 타입이 문자열인 경우</p>
<pre><code>let str: string = 'hi';</code></pre><p>: 를 이용해서 자바스크립트 코드에 타입을 정의하는 방식을 <strong><em>타입 표기</em></strong>라고 함.</p>
</li>
<li><p>숫자(number)</p>
<pre><code>let num: number = 10;</code></pre></li>
<li><p>진위(boolean)</p>
<pre><code>let isLoggedIn: boolean = false;</code></pre></li>
<li><p><em><strong>객체(object)</strong></em> : interface, class의 상위타입. 타입을 object로 정의하면, any 타입 처럼 모든 타입의 값을 정의할 수 있음</p>
</li>
</ul>
<pre><code>let obj: object = {name: 'NAME', age:29};
  obj={A: 'A', B: 'B'};</code></pre><p>  ❗️객체를 object 타입으로 정의하는 경우 타입스크립트를 사용한 목적이 애매해질 수 있음.
  (타입스크립트는 타입 검사에 엄격한 편임)</p>
<ul>
<li>interface로 구현</li>
</ul>
<pre><code class="language-typescript">          interface IUser {
            name: string,
            age : number
          }

          let obj: IUser = { name: 'NAME', age: 29 };</code></pre>
<ul>
<li>type으로 구현</li>
</ul>
<pre><code class="language-typescript">          type UserType = {
            name: string,
            age : number
          }

          let obj: UserType = { name: 'NAME', age: 29 };</code></pre>
<hr />
<ul>
<li>배열 (array)</li>
</ul>
<pre><code>let arr: number[] = [1,2,3];</code></pre><pre><code>// 제네릭 사용
  let arr: Array&lt;number&gt; = [1,2,3];</code></pre><ul>
<li>튜플(tuple): 튜플은 배열의 길이가 고정되고 각 요소의 타입이 지정되어 있는 배열 형식</li>
</ul>
<pre><code>let arr: [string, number] = ['hi', 10];</code></pre><p>만약에 정의하지 않은 타입, 인덱스로 접근할 경우 오류 남.</p>
<pre><code>arr[1].concat('!'); // Error, 'number' does not have 'concat'
arr[5] = 'hello'; // Error, Property '5' does not exist on type '[string, number]'</code></pre><ul>
<li>이넘(enum): 흔하게 쓰이는 타입으로 특정 값(상수)들의 집합을 의미하며 열거형 타입을 정의하는 데 사용됨. 이넘은 특정 값들의 집합을 이름으로 관리하고, 이러한 값을 논리적으로 그룹화할 수 있게 해줌.</li>
</ul>
<pre><code>enum Avengers { 
  Capt, 
  IronMan, 
  Thor 
}

let hero: Avengers = Avengers.Capt;</code></pre><p>❗️ enum은 인덱스 번호로도 접근가능함.</p>
<pre><code>enum Avengers { 
  Capt, 
  IronMan, 
  Thor 
}

let hero: Avengers = Avengers[0];</code></pre><ul>
<li>any: 특정 데이터의 타입을 잘 모르거나 자바스크립트 프로젝트에 타입스크립트를 점진적으로 적용할 때 사용하면 좋은 타입임. 단어 의미 그대로 모든 타입에 대해서 허용한다는 의미를 갖고 있음.
그러나 any 타입을 많이 사용하면 사용할수록 타입스크립트의 장점이 사라질 수 있음.</li>
</ul>
<pre><code>let str: any = 'hi';
let num: any = 10;
let arr: any = ['a', 2, true];</code></pre><ul>
<li>void: 반환 값이 없는 함수의 반환타입. return이 없거나 return이 있더라도 반환하는 값이 없으면 함수의 반환 타입을 void로 지정함.</li>
</ul>
<pre><code>function printSomething(): void {
  console.log('sth');
}

function returnNothing(): void {
  return;
}</code></pre><ul>
<li>never: 절대 발생하지 않는 값을 의미하는 타입임. 함수가 반복문이나 에러 핸들링으로 인해 함수의 끝에 절대 도달하지 않는 경우에 never 타입을 사용할 수 있음</li>
</ul>
<pre><code>// 이 함수는 절대 함수의 끝까지 실행되지 않는다는 의미
function loopForever(): never {
  while (true) {
    // ..
  }
}

function neverEnd(): never {
  throw new Error('unexpected');
}
</code></pre>